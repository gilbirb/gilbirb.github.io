---
layout: course
title: COMP2521
permalink: /courses/comp2521/
toc: true
---

## **Graphs**
---
### **Graph Basics**
---
blabla

### **Graph Traversals**
---
Graphs aren't very useful if all we're doing is storing data in them.
We need to effectively search and traverse them to gather information. \\
There are three 3 main topics related to traversal:

1. Traverse for Item Searching
   - Move between nodes to look for a value
2. Traverse for Path Finding
   - Look for a value, but keep track on how to get there
3. Traverse Fully
   - Like path-finding but exploring the full graph

There are two primary methods to traverse a graph:
* Breadth-first search (BFS)
  - Iterative solutions
* Depth-first search (DFS)
  - Recursive & iterative solutions
<img src="/assets/images/comp2521/dfsbfs.gif" alt="Graph Traversal Animation" width="500"/>\\
Both approaches ignore some edges by remembering previously visited vertices,
usually done in a visited[] array (this also prevents cycles).

**Breadth First Search**\\
Start at a node, and expanding out equally from there. Visit all the neighbours
of the current vertex, then visit all the neighbours of those neighbours, etc.

```
bfs(G, src):
  Input: graph G, starting vertex src
  create predecessor array, initialised to -1
  create queue Q

  visited[src] = src
  enqueue src into Q

  while Q is not empty:
    v = dequeue from Q
    for each neighbour w of v in G where predecessor[w] = -1:
      predecessor[w] = v
      enqueue w into Q
```
Analysis:\\
BFS is $O(V+E)$ when using adjacency list:
  * Typical queue implementation has $O(1)$ enqueue and dequeue
  * Each vertex is visited at most once $\implies$ $O(V)$
  * For each vertex, all of its edges are considered once $\implies$ $O(E)$

Path Finding:\\
A BFS finds the shortest path between the starting vertex and all other
vertices. \\
The shortest path between $src$ and $dest$ can be found by tracing backwards
through the predecessor array (from $dest$ to $src$).
```
bfsFindPath(G, src, dest):
  Input: graph  G, vertices src and dest
  ... Execute BFS starting from src ...
  
  if predecessor[dest] != -1:
    v = dest
    while v != src:
      print v "<-"
      v = predecessor[v]
    print src
```
In short, we first check if $dest$ was reached or not, then backtrack from $dest$
to $src$ using the $predecessor$ array. For example, finding a path from vertex $3$ to $8$ can print out:
```
8 <- 2 <- 5 <- 1 <- 3
```
**Depth First Search**