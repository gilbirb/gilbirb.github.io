---
layout: course
title: COMP2521
permalink: /courses/comp2521/
toc: false
---

<!-- to preview: bundle exec jekyll serve --livereload -->

## **Graphs**
***

### **Graph Basics**
***

blabla

### **Graph Traversals**
***
Graphs aren't very useful if all we're doing is storing data in them.
We need to effectively search and traverse them to gather information. \\
There are three 3 main topics related to traversal:

1. Traverse for Item Searching
   - Move between nodes to look for a value
2. Traverse for Path Finding
   - Look for a value, but keep track on how to get there
3. Traverse Fully
   - Like path-finding but exploring the full graph

There are two primary methods to traverse a graph:
* Breadth-first search (BFS)
  - Iterative solutions
* Depth-first search (DFS)
  - Recursive & iterative solutions
<img src="/assets/images/comp2521/dfsbfs.gif" alt="Graph Traversal Animation" width="500"/>\\
Both approaches ignore some edges by remembering previously visited vertices,
usually done in a visited[] array (this also prevents cycles).

**Breadth First Search**\\
Start at a node, and expanding out equally from there. Visit all the neighbours
of the current vertex, then visit all the neighbours of those neighbours, etc.

```
bfs(G, src):
  Input: graph G, starting vertex src
  create predecessor array, initialised to -1
  create queue Q

  visited[src] = src
  enqueue src into Q

  while Q is not empty:
    v = dequeue from Q
    for each neighbour w of v in G where predecessor[w] = -1:
      predecessor[w] = v
      enqueue w into Q
```
Analysis:\\
BFS is $O(V+E)$ when using adjacency list:
  * Typical queue implementation has $O(1)$ enqueue and dequeue
  * Each vertex is visited at most once $\implies$ $O(V)$
  * For each vertex, all of its edges are considered once $\implies$ $O(E)$

Path Finding:\\
A BFS finds the shortest path between the starting vertex and all other
vertices. \\
The shortest path between $src$ and $dest$ can be found by tracing backwards
through the predecessor array (from $dest$ to $src$).
```
bfsFindPath(G, src, dest):
  Input: graph  G, vertices src and dest
  ... Execute BFS starting from src ...
  
  if predecessor[dest] != -1:
    v = dest
    while v != src:
      print v "<-"
      v = predecessor[v]
    print src
```
In short, we first check if $dest$ was reached or not, then backtrack from $dest$
to $src$ using the $predecessor$ array. For example, finding a path from vertex $3$ to $8$ can print out:
```
8 <- 2 <- 5 <- 1 <- 3
```
**Depth First Search**

Goes as far down one path as possible until it reaches a dead end, then
backtracks until it finds a new path to take, then repeats.

DFS can be implemented recursively or iteratively.

```
dfs(G, src):
  Input: graph G, starting vertex src

  create visited array, initialised to false
  dfsRec(G, src, visited)

dfsRec(G, v, visited):
  Input: graph G, vertex v, visited array

  visited[v] = true
  for each neighbour w of v in G:
    if visited[w] = false:
      dfsRec(G, w, visited)
```
Analysis:

Recursive DFS is $O(V + E)$ when using adjacency list representation:
  * Each vertex is visited at most once $\implies O(V)$
    * Function is called on each vertex once
  * For each vertex, all of its edges are considered once $\implies O(E)$ 

Path Checking:

Recursive DFS can be adapted to check if a path exists between two vertices.

```
dfsHasPath(G, src, dest):
  Input: graph G, vertices src and dest
  Output: true if there is a path from src to dest, false otherwise

  create visited array, initialised to false
  return dfsHasPathRec(G, src, dest, visited)

dfsHasPathRec(G, v, dest, visited):
  Input: graph G, vertices v and dest, visited array

  visited[v] = true
  if (v = dest):
    return true

  for each neighbour w of v in G:
    if visited[w] = false:
      if dfsHasPathRec(G, w, dest, visited):
        return true
  
  return false
```

Path-Finding:

```
dfsFindPath(G, src, dest):
  Input: graph G, vertices src and dest

  create predecessor array, initialised to -1
  predecessor[src] = src

  if dfsFindPathRec(G, src, dest, predecessor):
    v = dest
    while v != src:
      print v, "<-"
      v = predecessor[v]

    print src
```

Iterative Implementation:

DFS can be implemented iteratively using stack

```
dfs(G, src):
  Input: graph G, vertex src

  create visited array, initialised to false
  create predecessor array, initialised to -1
  create stack S

  push src onto S

  while S is not empty:
    v = pop from S
    if visited[v] = true:
      continue

    visited[v] = true

    for each neighbour w of v in G where visited[w] = false
      predecessor[w] = v
      push w onto S
```

**Spanning Trees**

The edges traversed in a graph traversal form a spanning tree.

A traversal starting at vertex ‘a’ forms the following spanning trees:

<img src="/assets/images/comp2521/spanningtreediff.png" alt="Graph Spanning Tree Difference" width="750"/>

**Disconnected Graphs**

If a graph is not connected, a graph traversal starting from a given vertex
will not traverse the entire graph.

Solution:

After initial traversal is complete,
perform traversal again on an unvisited vertex,
repeat until all vertices are visited
This produces a spanning forest

<img src="/assets/images/comp2521/spanningforest.png" alt="Graph Spanning Tree Difference" width="750"/>

```
dfs(G):
  Input: graph G

  create predecessor array, initialised to -1

  for each vertex v in G:
    if predecessor[v] = -1:
      dfsRec(G, v, predecessor)
  ...
```